- content_for :head do
  %title Mongoid: Relations

%h1 Relations

%p
  Relations are associations between one model and another in the domain
  and in the database. Embedded relations describe documents who are
  stored inside other documents in the database. Referenced relations
  describe documents that reference documents in another collection by
  storing foreign key data (usually an id) about the other document
  in itself.

%p
  All relation objects in Mongoid are proxies to the actual document or
  documents themselves, which provide extra functionality for accessing,
  replacing, appending and persisting.

.page-nav
  .container
    %ul.nav.nav-pills
      %li= link_to "Common Behaviour", "#common"
      %li= link_to "Metadata", "#metadata"
      %li= link_to "Embedded 1-1", "#embeds_one"
      %li= link_to "Embedded 1-n", "#embeds_many"
      %li= link_to "Referenced 1-1", "#has_one"
      %li= link_to "Referenced 1-n", "#has_many"
      %li= link_to "Referenced n-n", "#has_and_belongs_to_many"

%section#common
  %h2 Common Behaviour

  %h3 Attributes

  %p
    All relations contain a <code>target</code>, which is the proxied document
    or documents, a <code>base</code> which is the document the relation hangs
    off, and <code>metadata</code> which provides information about the relation.

  :coderay
    #!ruby

    class Person
      include Mongoid::Document
      embeds_many :addresses
    end

    person.addresses = [ address ]
    person.addresses.target # returns [ address ]
    person.addresses.base # returns person
    person.addresses.metadata # returns the metadata

  %h3 Extensions

  %p
    All relations can have extensions, which provides a way to add
    application specific functionality to the relation. They are defined by
    providing a block to the relation definition.

  :coderay
    #!ruby

    class Person
      include Mongoid::Document
      embeds_many :addresses do
        def find_by_country(country)
          where(country: country).first
        end
        def chinese
          @target.select { |address| address.country == "China"}
        end
      end
    end

    person.addresses.find_by_country("Mongolia") # returns address
    person.addresses.chinese # returns [ address ]

  %h3 Custom Relation Names

  %p
    You can name your relations whatever you like, but if the class cannot be
    inferred by Mongoid from the name, and neither can the opposite side you'll
    want to provide the macro with some additional options to tell Mongoid
    how to hook them up.

  :coderay
    #!ruby

    class Lush
      include Mongoid::Document
      embeds_one :whiskey, class_name: "Drink", inverse_of: :alcoholic
    end

    class Drink
      include Mongoid::Document
      embedded_in :alcoholic, class_name: "Lush", inverse_of: :whiskey
    end

  %h3 Validations

  %p
    It is important to note that by default, Mongoid will validate the
    children of any relation that are loaded into memory via a
    <code>validates_associated</code>. The relations that this applies to are:

    %ul
      %li <code>embeds_many</code>
      %li <code>embeds_one</code>
      %li <code>has_many</code>
      %li <code>has_one</code>
      %li <code>has_and_belongs_to_many</code>

  %p
    If you do not want this behavior, you may turn it off when defining
    the relation.

  :coderay
    #!ruby
    class Person
      include Mongoid::Document

      embeds_many :addresses, validate: false
      has_many :posts, validate: false
    end

  %h3 Polymorphism

  %p
    When a child embedded document can belong to more than one type of parent
    document, you can tell Mongoid to support this by adding the <code>as</code>
    option to the definition on the parents, and the <code>polymorphic</code>
    option on the child. On the child object, an additional field will be
    stored that indicates the type of the parent.

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p
            Polymorhic behavior is allowed on all relations with the
            exception of <code>has_and_belongs_to_many</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      embeds_many :photos, as: :photographic
      has_one :address, as: :addressable
    end

    class Photo
      include Mongoid::Document
      embedded_in :photographic, polymorphic: true
    end

    class Address
      include Mongoid::Document
      belongs_to :addressable, polymorphic: true
    end

  %h3 Cascading Callbacks

  %p
    If you want the embedded document callbacks to fire when calling a persistence
    operation on its parent, you will need to provide the cascade callbacks
    option to the relation.

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p
            Cascading callbacks is only available on <code>embeds_one</code>
            and <code>embeds_many</code> relations.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      embeds_many :albums, cascade_callbacks: true
      embeds_one :label, cascade_callbacks: true
    end

    band.save # Fires all save callbacks on the band, albums, and label.

  %h3 Dependent Behaviour

  %p
    You can provided dependent options to referenced associations to
    instruct Mongoid how to handle situations where one side of the
    relation is deleted, or is attempted to be deleted. The options
    are as follows:

  %ul
    %li <code>:delete</code>: Delete the child document.
    %li <code>:destroy</code>: Destroy the child document.
    %li <code>:nullify</code>: Orphan the child document.
    %li <code>:restrict</code>: Raise an error if the child is not empty.

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p Dependent options are only available on referenced relations.

  %p
    The default behavior of each association when no dependent option
    is provided is to nullify.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      has_many :albums, dependent: :delete
      belongs_to :label, dependent: :nullify
    end

    class Album
      include Mongoid::Document
      belongs_to :band
    end

    class Label
      include Mongoid::Document
      has_many :bands, dependent: :restrict
    end

    label = Label.first
    label.bands.push(Band.first)
    label.delete # Raises an error since bands is not empty.

    Band.first.delete # Will delete all associated albums.

  %h3 Autosaving

  %p
    One core difference between Mongoid and Active Record from a behavior
    standpoint is that Mongoid does not automatically save child relations
    for relational associations. This is for performance reasons.

  %p
    To enable an autosave on a relational association (embedded associations
    do not need this since they are actually part of the parent in the
    database) add the <code>autosave</code> option to the relation.

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          Note that autosave functionality will automatically be added to a
          relation when using <code>accepts_nested_attributes_for</code> or
          validating presence of the relation.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      has_many :albums, autosave: true
    end

    band = Band.first
    band.albums.build(name: "101")
    band.save #=> Will save the album as well.

  %h3 Recursive Embedding

  %p
    A document can recursively embed itself using
    <code>recursively_embeds_one</code> or <code>recursively_embeds_many</code>,
    which provides accessors for the parent and children via <code>parent_</code>
    and <code>child_</code> methods.

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p Recursive options are only available on embedded relations.

  :coderay
    #!ruby

    class Tag
      include Mongoid::Document
      recursively_embeds_many
    end

    root = Tag.new(name: "programming")
    child_one = root.child_tags.build
    child_two = root.child_tags.build

    root.child_tags # [ child_one, child_two ]
    child_one.parent_tag # [ root ]
    child_two.parent_tag # [ root ]

    class Node
      include Mongoid::Document
      recursively_embeds_one
    end

    root = Node.new
    child = Node.new
    root.child_node = child

    root.child # child
    child.parent_node # root

  %h3 Existence Predicates

  %p
    All relations have existence predicates on them in the form of
    <code>name?</code> and <code>has_name?</code> to check if the relation
    is blank.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      embeds_one :label
      embeds_many :albums
    end

    band.label?
    band.has_label?
    band.albums?
    band.has_albums?

  %h3 Autobuilding

  %p
    One to one relations (<code>embeds_one</code>, <code>has_one</code>) have
    an <code>autobuild</code> option which tells Mongoid to instantiate a
    new document when the relation is accessed and it is <code>nil</code>

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p
            Existence predicates will not trigger an autobuild, so they will
            properly return <code>false</code> if the document is not
            present.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      embeds_one :label, autobuild: true
      has_one :producer, autobuild: true
    end

    band = Band.new
    band.label # Returns a new empty label.
    band.producer # Returns a new empty producer.

  %h3 Touching

  %p
    Any <code>belongs_to</code> relation, no matter where it hangs off from,
    can take an optional <code>:touch</code> option which will call the
    touch method on it and any parent relations with the option defined when
    the base document calls <code>#touch</code>.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      belongs_to :label, touch: true
    end

    band = Band.first
    band.touch #=> Calls touch on the parent label.

%section#metadata
  %h2 Metadata

  %p
    All relations in Mongoid contain metadata that holds information
    about the relation in question, and is a valuable tool for third
    party developers to use to extend Mongoid.

  %p
    You can access the metadata of the relation in a few different ways.

  :coderay
    #!ruby
    # Get the metadata for a named relation from the class or document.
    Model.reflect_on_association(:relation_name)
    model.reflect_on_association(:relation_name)

    # Get the metadata that the current object has in its relation.
    model.metadata

    # Get the metadata with a specific relation itself on a specific
    # document.
    person.addresses.metadata

  %h3 The Metadata Object

  %p
    The metadata object itself contains more information than one might
    know what to do with, and is useful for developers of extensions
    to Mongoid.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Method
        %th Description
    %tr
      %td <code>Metadata#as</code>
      %td Returns the name of the parent to a polymorphic child.
    %tr
      %td <code>Metadata#as?</code>
      %td Returns whether or not an as option exists.
    %tr
      %td <code>Metadata#autobuilding?</code>
      %td Returns whether or not the relation is autobuilding.
    %tr
      %td <code>Metadata#autosaving?</code>
      %td Returns whether or not the relation is autosaving.
    %tr
      %td <code>Metadata#cascading_callbacks?</code>
      %td
        Returns whether the relation has callbacks cascaded down from
        the parent.
    %tr
      %td <code>Metadata#class_name</code>
      %td Returns the class name of the proxied document.
    %tr
      %td <code>Metadata#cyclic?</code>
      %td Returns whether the relation is a cyclic relation.
    %tr
      %td <code>Metadata#dependent</code>
      %td Returns the relation's dependent option.
    %tr
      %td <code>Metadata#dependent?</code>
      %td Returns whether the relation is a dependent relation.
    %tr
      %td <code>Metadata#destructive?</code>
      %td Returns true if the relation has a dependent delete or destroy.
    %tr
      %td <code>Metadata#embedded?</code>
      %td Returns whether the relation is embedded in another document.
    %tr
      %td <code>Metadata#forced_nil_inverse?</code>
      %td Returns whether the relation has a nil inverse defined.
    %tr
      %td <code>Metadata#foreign_key</code>
      %td Returns the name of the foreign key field.
    %tr
      %td <code>Metadata#foreign_key_check</code>
      %td Returns the name of the foreign key field dirty check method.
    %tr
      %td <code>Metadata#foreign_key_setter</code>
      %td Returns the name of the foreign key field setter.
    %tr
      %td <code>Metadata#indexed?</code>
      %td Returns whether the foreign key is auto indexed.
    %tr
      %td <code>Metadata#inverses</code>
      %td Returns the names of all inverse relation.
    %tr
      %td <code>Metadata#inverse</code>
      %td Returns the name of a single inverse relation.
    %tr
      %td <code>Metadata#inverse_class_name</code>
      %td Returns the class name of the relation on the inverse side.
    %tr
      %td <code>Metadata#inverse_foreign_key</code>
      %td Returns the name of the foreign key field on the inverse side.
    %tr
      %td <code>Metadata#inverse_klass</code>
      %td Returns the class of the relation on the inverse side.
    %tr
      %td <code>Metadata#inverse_metadata</code>
      %td Returns the metadata of the relation on the inverse side.
    %tr
      %td <code>Metadata#inverse_of</code>
      %td Returns the explicitly defined name of the inverse relation.
    %tr
      %td <code>Metadata#inverse_of?</code>
      %td Returns whether an <code>inverse_of</code> option is defined.
    %tr
      %td <code>Metadata#inverse_setter</code>
      %td Returns the name of the method used to set the inverse.
    %tr
      %td <code>Metadata#inverse_type</code>
      %td Returns the name for the polymorphic type field of the inverse.
    %tr
      %td <code>Metadata#inverse_type_setter</code>
      %td Returns the name for the polymorphic type field setter of the inverse.
    %tr
      %td <code>Metadata#key</code>
      %td
        Returns the name of the field in the attributes hash to use to get
        the relation.
    %tr
      %td <code>Metadata#klass</code>
      %td Returns the class of the proxied documents in the relation.
    %tr
      %td <code>Metadata#macro</code>
      %td Returns the relation's macro.
    %tr
      %td <code>Metadata#name</code>
      %td Returns the relation name.
    %tr
      %td <code>Metadata#options</code>
      %td Returns self, for API compatibility with Active Record.
    %tr
      %td <code>Metadata#order</code>
      %td Returns the custom sorting options on the relation.
    %tr
      %td <code>Metadata#order?</code>
      %td Returns whether custom sorting options are set.
    %tr
      %td <code>Metadata#polymorphic?</code>
      %td Returns whether the relation is polymorphic.
    %tr
      %td <code>Metadata#setter</code>
      %td Returns the name of the field to set the relation.
    %tr
      %td <code>Metadata#store_as</code>
      %td Returns the name of the attribute to store an embedded relation in.
    %tr
      %td <code>Metadata#touchable?</code>
      %td Returns whether or not the relation has a touch option.
    %tr
      %td <code>Metadata#type</code>
      %td Returns the name of the field to get the polymorphic type.
    %tr
      %td <code>Metadata#type_setter</code>
      %td Returns the name of the field to set the polymorphic type.
    %tr
      %td <code>Metadata#validate?</code>
      %td Returns whether the relation has an associated validation.
    %tr
      %td <code>Metadata#versioned?</code>
      %td Returns whether the relation is an embedded version.

%section#embeds_one
  %h2 Embedded 1-1

  %p
    One to one relationships where the children are embedded in the parent
    document are defined using Mongoid's <code>embeds_one</code> and
    <code>embedded_in</code> macros.

  %h3 Defining

  %p
    The parent document of the relation should use the <code>embeds_one</code>
    macro to indicate is has 1 embedded child, where the document that
    is embedded uses <code>embedded_in</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      embeds_one :label
    end

    class Label
      include Mongoid::Document
      field :name, type: String
      embedded_in :band
    end

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p
            Definitions are required on both sides to the relation in order
            for it to work properly.

  %h3 Storage

  %p
    Documents that are embedded using the <code>embeds_one</code> macro are stored
    as a hash inside the parent in the parent's database collection.

  :coderay
    #!javascript

    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
      "label" : {
        "_id" : ObjectId("4d3ed089fb60ab534684b7e0"),
        "name" : "Mute",
      }
    }

  %p
    You can optionally tell Mongoid to store the embedded document in a
    different attribute other than the name, by providing a <code>:store_as</code>
    option.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      embeds_one :label, store_as: "lab"
    end

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the embedded document.
        %td
          :coderay
            #!ruby
            band.label
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the embedded document. If the parent document is persisted,
              then the child will be atomically saved immediately. If setting
              to <code>nil</code> then the child will be deleted.
        %td
          :coderay
            #!ruby
            band.label = Label.new(name: "Mute")

            band.label = nil
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { label: { name: "Mute" }}
              )

            collections[:bands].find(...).
              update("$unset" => { label: true })

      %tr
        %td.doc
          <code>Model\#{parent_name}</code>
          %p.doc
            %i
              Get the parent document from the child.
        %td
          :coderay
            #!ruby
            label.band
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}=</code>
          %p.doc
            %i
              Set the parent document from the child.
        %td
          :coderay
            #!ruby
            label.band = Band.new
        %td
      %tr
        %td.doc
          <code>Model#build_{name}</code>
          %p.doc
            %i
              Build a new document on the relation.
        %td
          :coderay
            #!ruby
            band.build_label(name: "Mute")

            label.build_band(name: "Depeche Mode")
        %td
      %tr
        %td.doc
          <code>Model#create_{name}</code>
          %p.doc
            %i
              Create a new document from either side of the relation.
              This persists the child immediately if executing from the parent,
              and persists the entire tree if executed from the child.
        %td
          :coderay
            #!ruby
            band.create_label(name: "Mute")

            label.create_band({
              name: "Depeche Mode"
            })
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { label: { name: "Mute" }}
              )

            collections[:bands].
              insert({
                name: "Depeche Mode",
                label: { name: "Mute" }
              })

%section#embeds_many
  %h2 Embedded 1-n

  %p
    One to many relationships where the children are embedded in the parent
    document are defined using Mongoid's <code>embeds_many</code> and
    <code>embedded_in</code> macros.

  %h3 Defining

  %p
    The parent document of the relation should use the <code>embeds_many</code>
    macro to indicate it has <i>n</i> number of embedded children, where
    the document that is embedded uses <code>embedded_in</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      embeds_many :albums
    end

    class Album
      include Mongoid::Document
      field :name, type: String
      embedded_in :band
    end

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p
            Definitions are required on both sides to the relation in order
            for it to work properly.

  %h3 Storage

  %p
    Documents that are embedded using the <code>embeds_many</code> macro are stored
    as an array of hashes inside the parent in the parent's database
    collection.

  :coderay
    #!javascript

    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
      "albums" : [
        {
          "_id" : ObjectId("4d3ed089fb60ab534684b7e0"),
          "name" : "Violator",
        }
      ]
    }

  %p
    You can optionally tell Mongoid to store the embedded document in a
    different attribute other than the name, by providing a <code>:store_as</code>
    option.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      embeds_many :albums, store_as: "albs"
    end

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the embedded documents.
        %td
          :coderay
            #!ruby
            band.albums
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the embedded documents. If the parent document is persisted,
              then the child will be atomically saved immediately. If setting
              to <code>nil</code> or <code>[]</code> then the children will be
              deleted.
        %td
          :coderay
            #!ruby
            band.albums = [ Album.new(name: "Violator") ]

            band.albums = nil
            band.albums = []
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { albums: [{ name: "Violator" }]}
              )

            collections[:bands].find(...).
              update("$unset" => { albums: true })

      %tr
        %td.doc
          <code>Model\#{parent_name}</code>
          %p.doc
            %i
              Get the parent document from any child.
        %td
          :coderay
            #!ruby
            album.band
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}=</code>
          %p.doc
            %i
              Set the parent document from a child.
        %td
          :coderay
            #!ruby
            album.band = Band.new
        %td
      %tr
        %td.doc
          <code>Model\#{name}.<<</code><br/>
          <code>Model\#{name}.push</code>
          %p.doc
            %i
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
        %td
          :coderay
            #!ruby
            band.albums << Album.new(name: "Violator")
            band.albums.push(Album.new(name: "Violator"))
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$push" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.concat</code>
          %p.doc
            %i
              Push multiple documents onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
              <b>Note that while batch operations limit the number
              of database calls to a single one for the new documents, it
              is in fact at least 2x slower from the Ruby side. This is due
              to the fact that 2 iterations over all documents must occur
              to ensure that all the before callbacks run before the db hit,
              and that all after callbacks have to wait until after.</b>
        %td
          :coderay
            #!ruby
            band.albums.concat(
              Album.new(name: "Violator"),
              Album.new(name: "101")
            )
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pushAll" => {
                  albums: [{ name: "Violator" }, { name: "101" }]
                }
              )
      %tr
        %td.doc
          <code>Model\#{name}.build</code><br/>
          <code>Model\#{name}.new</code>
          %p.doc
            %i
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
        %td
          :coderay
            #!ruby
            band.albums.build(name: "Violator")
            band.albums.new(name: "Violator")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.create</code><br/>
          <code>Model\#{name}.create!</code>
          %p.doc
            %i
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
        %td
          :coderay
            #!ruby
            band.albums.create(name: "Violator")
            band.albums.create!(name: "Violator")
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$push" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.clear</code><br/>
          <code>Model\#{name}.delete_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, without
              running any callbacks.
        %td
          :coderay
            #!ruby
            band.albums.clear
            band.albums.delete_all
            band.albums.delete_all(name: "Violator")
            band.albums.
              where(name: "Violator").delete_all
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pullAll" => { albums: [{ name: "Violator" }]}
              )
      %tr
        %td.doc
          <code>Model\#{name}.destroy_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, while
              running the destroy callbacks.
        %td
          :coderay
            #!ruby
            band.albums.destroy_all
            band.albums.destroy_all(name: "Violator")
            band.albums.
              where(name: "Violator").destroy_all
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pullAll" => { albums: [{ name: "Violator" }]}
              )
      %tr
        %td.doc
          <code>Model\#{name}.delete</code>
          %p.doc
            %i
              Deletes the matching document from the relation.
        %td
          :coderay
            #!ruby
            band.albums.delete(album)
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pull" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.pop</code>
          %p.doc
            %i
              Deletes the provided number of documents, defaulting to 1.
        %td
          :coderay
            #!ruby
            band.albums.pop
            band.albums.pop(1)
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pullAll" => { albums: [{ name: "Violator" }]}
              )
      %tr
        %td.doc
          <code>Model\#{name}.find</code>
          %p.doc
            %i
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
        %td
          :coderay
            #!ruby
            band.albums.find(id)
            band.albums.find(id_one, id_two)
        %td
      %tr
        %td.doc
          <code>Model\#{name}.find_or_create_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              create a newly persisted one.
        %td
          :coderay
            #!ruby
            band.albums.
              find_or_create_by(name: "Violator")
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$push" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.find_or_initialize_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              add a new one.
        %td
          :coderay
            #!ruby
            band.albums.
              find_or_initialize_by(name: "Violator")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.where</code>
          %p.doc
            %i
              Find matching documents in the relation. This can be any
              criteria method, not just where.
        %td
          :coderay
            #!ruby
            band.albums.where(name: "Violator")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.exists?</code>
          %p.doc
            %i
              Returns whether or not the relation has any documents.
        %td
          :coderay
            #!ruby
            band.albums.exists?
        %td

%section#has_one
  %h2 Referenced 1-1

  %p
    One to one relationships where the children are referenced in the parent
    document are defined using Mongoid's <code>has_one</code> and
    <code>belongs_to</code> macros.

  %h3 Defining

  %p
    The parent document of the relation should use the <code>has_one</code>
    macro to indicate is has 1 referenced child, where the document that
    is referenced in it uses <code>belongs_to</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      has_one :studio
    end

    class Studio
      include Mongoid::Document
      field :name, type: String
      belongs_to :band
    end

  %p
    Definitions are required on both sides to the relation in order for it to
    work properly.

  %h3 Storage

  %p
    When defining a relation of this nature, each document is stored in its
    respective collection, but the child document contains a "foreign key"
    reference to the parent.

  :coderay
    #!ruby

    # The parent band document.
    { "_id" : ObjectId("4d3ed089fb60ab534684b7e9") }

    # The child studio document.
    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7f1"),
      "band_id" : ObjectId("4d3ed089fb60ab534684b7e9")
    }

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the child document.
        %td
          :coderay
            #!ruby
            band.studio
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the child document. If the parent document is persisted,
              then the child will be saved immediately. If setting
              to <code>nil</code> then the child will be deleted.
        %td
          :coderay
            #!ruby
            band.studio = Studio.new(name: "Abbey Road")

            band.studio = nil
        %td
          :coderay
            #!ruby
            collections[:studios].insert(
              { name: "Abbey Road", band_id: ... }
            )

            collections[:studios].find(...).remove

      %tr
        %td.doc
          <code>Model\#{parent_name}</code>
          %p.doc
            %i
              Get the parent document from the child.
        %td
          :coderay
            #!ruby
            studio.band
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}=</code>
          %p.doc
            %i
              Set the parent document from the child.
        %td
          :coderay
            #!ruby
            studio.band = Band.new
        %td
      %tr
        %td.doc
          <code>Model#build_{name}</code>
          %p.doc
            %i
              Build a new document on the relation. This does not save the
              new document.
        %td
          :coderay
            #!ruby
            band.build_studio(name: "Abbey Road")

            studio.build_band(name: "Depeche Mode")
        %td
      %tr
        %td.doc
          <code>Model#create_{name}</code>
          %p.doc
            %i
              Create a new document from either side of the relation.
              This persists the child immediately if executing from the parent,
              and persists the parent if executed from the child.
        %td
          :coderay
            #!ruby
            band.create_studio(name: "Abbey Road")

            studio.create_band(name: "Depeche Mode")
        %td
          :coderay
            #!ruby
            collections[:studios].insert(
              { name: "Abbey Road", band_id: ... }
            )

            collections[:bands].insert(
              { name: "Depeche Mode" }
            )

%section#has_many
  %h2 Referenced 1-n

  %p
    One to many relationships where the children are stored in a
    separate collection from the parent document are defined using
    Mongoid's <code>has_many</code> and <code>belongs_to</code> macros. This
    exhibits similar behavior to Active Record.

  %h3 Defining

  %p
    The parent document of the relation should use the <code>has_many</code>
    macro to indicate is has <i>n</i> number of referenced children, where
    the document that is referenced uses <code>belongs_to</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      has_many :members
    end

    class Member
      include Mongoid::Document
      field :name, type: String
      belongs_to :band
    end

  %p
    Definitions are required on both sides to the relation in order for it to
    work properly.

  %h3 Storage

  %p
    When defining a relation of this nature, each document is stored in its
    respective collection, but the child document contains a "foreign key"
    reference to the parent.

  :coderay
    #!ruby

    # The parent band document.
    { "_id" : ObjectId("4d3ed089fb60ab534684b7e9") }

    # The child member document.
    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7f1"),
      "band_id" : ObjectId("4d3ed089fb60ab534684b7e9")
    }

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the related documents.
        %td
          :coderay
            #!ruby
            band.members
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the related documents. If the parent document is persisted,
              then the child will be saved immediately. If setting
              to <code>nil</code> or <code>[]</code> then the children will be
              deleted.
        %td
          :coderay
            #!ruby
            band.members = [ Member.new(name: "Fletch") ]

            band.members = nil
            band.members = []
        %td
          :coderay
            #!ruby
            collections[:members].insert(
              { name: "Fletch", band_id: ... }
            )

            collections[:members].find(...).remove
      %tr
        %td.doc
          <code>Model\#{name}_ids</code>
          %p.doc
            %i Get the related document ids.
        %td
          :coderay
            #!ruby
            band.member_ids
        %td
      %tr
        %td.doc
          <code>Model\#{name}_ids=</code>
          %p.doc
            %i
              Set the related document ids.
        %td
          :coderay
            #!ruby
            band.member_ids = [ id ]
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}</code>
          %p.doc
            %i
              Get the parent document from any child.
        %td
          :coderay
            #!ruby
            member.band
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}=</code>
          %p.doc
            %i
              Set the parent document from a child.
        %td
          :coderay
            #!ruby
            member.band = Band.new
        %td
      %tr
        %td.doc
          <code>Model\#{name}.<<</code><br/>
          <code>Model\#{name}.push</code>
          %p.doc
            %i
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
        %td
          :coderay
            #!ruby
            band.members << Member.new(name: "Fletch")
            band.members.push(Member.new(name: "Fletch"))
        %td
          :coderay
            #!ruby
            collections[:members].insert(
              { name: "Fletch", band_id: ... }
            )
      %tr
        %td.doc
          <code>Model\#{name}.concat</code>
          %p.doc
            %i
              Push multiple documents onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved in a single batch.
              <b>Note that while batch operations limit the number
              of database calls to a single one for the new documents, it
              is in fact at least 2x slower from the Ruby side. This is due
              to the fact that 2 iterations over all documents must occur
              to ensure that all the before callbacks run before the db hit,
              and that all after callbacks have to wait until after.</b>
        %td
          :coderay
            #!ruby
            band.members.concat(
              Member.new(name: "Fletch"),
              Member.new(name: "Martin")
            )
        %td
          :coderay
            #!ruby
            collections[:members].insert([
              { name: "Fletch", band_id: ... },
              { name: "Martin", band_id: ... }
            ])
      %tr
        %td.doc
          <code>Model\#{name}.build</code><br/>
          <code>Model\#{name}.new</code>
          %p.doc
            %i
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
        %td
          :coderay
            #!ruby
            band.members.build(name: "Fletch")
            band.members.new(name: "Fletch")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.create</code><br/>
          <code>Model\#{name}.create!</code>
          %p.doc
            %i
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
        %td
          :coderay
            #!ruby
            band.members.create(name: "Fletch")
            band.members.create!(name: "Fletch")
        %td
          :coderay
            #!ruby
            collections[:members].insert(
              { name: "Fletch", band_id: ... }
            )
      %tr
        %td.doc
          <code>Model\#{name}.clear</code><br/>
          <code>Model\#{name}.delete_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, without
              running any callbacks.
        %td
          :coderay
            #!ruby
            band.members.clear
            band.members.delete_all
            band.members.delete_all(name: "Fletch")
            band.members.
              where(name: "Fletch").delete_all
        %td
          :coderay
            #!ruby
            collections[:members].find(band_id: ...).remove_all

            collections[:members].
              find(band_id: ..., name: "Fletch").remove_all
      %tr
        %td.doc
          <code>Model\#{name}.destroy_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, while
              running the destroy callbacks.
        %td
          :coderay
            #!ruby
            band.members.destroy_all
            band.members.destroy_all(name: "Fletch")
            band.members.
              where(name: "Fletch").destroy_all
        %td
          :coderay
            #!ruby
            collections[:members].find(band_id: ...).remove_all

            collections[:members].
              find(band_id: ..., name: "Fletch").remove_all
      %tr
        %td.doc
          <code>Model\#{name}.delete</code>
          %p.doc
            %i
              Deletes the matching document from the relation.
        %td
          :coderay
            #!ruby
            band.members.delete(member)
        %td
          :coderay
            #!ruby
            collections[:members].
              find(band_id: ..., name: "Fletch").remove
      %tr
        %td.doc
          <code>Model\#{name}.find</code>
          %p.doc
            %i
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
        %td
          :coderay
            #!ruby
            band.members.find(id)

            band.members.find(id_one, id_two)
        %td
          :coderay
            #!ruby
            collections[:members].find({
              band_id: ..., _id: id
            })

            collections[:members].find({
              band_id: ..., _id: { "$in" => [ id_one, id_two ] }
            })
      %tr
        %td.doc
          <code>Model\#{name}.find_or_create_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              create a newly persisted one.
        %td
          :coderay
            #!ruby
            band.members.
              find_or_create_by(name: "Fletch")
        %td
          :coderay
            #!ruby
            collections[:members].find({
              band_id: ..., name: "Fletch"
            })
            collections[:members].insert(
              { name: "Fletch", band_id: ... }
            )
      %tr
        %td.doc
          <code>Model\#{name}.find_or_initialize_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              add a new one.
        %td
          :coderay
            #!ruby
            band.members.
              find_or_initialize_by(name: "Fletch")
        %td
          :coderay
            #!ruby
            collections[:members].find({
              band_id: ..., name: "Fletch"
            })
      %tr
        %td.doc
          <code>Model\#{name}.where</code>
          %p.doc
            %i
              Find matching documents in the relation. This can be any
              criteria method, not just where.
        %td
          :coderay
            #!ruby
            band.members.where(name: "Fletch")
        %td
          :coderay
            #!ruby
            collections[:members].find({
              band_id: ..., name: "Fletch"
            })
      %tr
        %td.doc
          <code>Model\#{name}.exists?</code>
          %p.doc
            %i
              Returns whether or not the relation has any documents.
        %td
          :coderay
            #!ruby
            band.members.exists?
        %td
          :coderay
            #!ruby
            collections[:members].find(band_id: ...).count

%section#has_and_belongs_to_many
  %h2 Referenced n-n

  %p
    Many to many relationships where the inverse documents are stored in a
    separate collection from the base document are defined using
    Mongoid's <code>has_and_belongs_to_many</code> macro. This
    exhibits similar behavior to Active Record with the exception that
    no join collection is needed, the foreign key ids are stored as
    arrays on either side of the relation.

  %h3 Defining

  %p
    Both sides of the relation use the same macro.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      has_and_belongs_to_many :tags
    end

    class Tag
      include Mongoid::Document
      field :name, type: String
      has_and_belongs_to_many :bands
    end

  %p
    You can create a one sided many to many if you want to mimic a has_many
    that stores the keys as an array on the parent.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      has_and_belongs_to_many :tags, inverse_of: nil
    end

    class Tag
      include Mongoid::Document
      field :name, type: String
    end

  %h3 Storage

  %p
    When defining a relation of this nature, each document is stored in its
    respective collection, and each document contains a "foreign key"
    reference to the other in the form of an array.

  :coderay
    #!ruby

    # The band document.
    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
      "tag_ids" : [ ObjectId("4d3ed089fb60ab534684b7f2") ]
    }

    # The tag document.
    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7f2"),
      "band_ids" : [ ObjectId("4d3ed089fb60ab534684b7e9") ]
    }

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  .well
    %table
      %tr
        %td.achtung= image_tag "/images/achtung.png"
        %td.note
          %p
            Many to many relations require usually double the amount of
            hits to the database to keep both sides of the relation in
            sync, since keys are stored on both sides. Due to this they
            are slower and should be used with caution.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the related documents.
        %td
          :coderay
            #!ruby
            band.tags
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the related documents. If the parent document is persisted,
              then the child will be saved immediately along with the parent to
              keep the keys consistent. If setting to <code>nil</code> or
              <code>[]</code> then the children will be deleted.
        %td
          :coderay
            #!ruby
            band.tags = [ Tag.new(name: "electro") ]

            band.tags = nil
            band.tags = []
        %td
          :coderay
            #!ruby
            collections[:tags].insert(
              { name: "electro", band_ids: ... }
            )
            collections[:bands].find(...).
              update("$push" => { tag_ids: ... })

            collections[:tags].find(...).remove
            collections[:bands].find(...).
              update("$pull" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.<<</code><br/>
          <code>Model\#{name}.push</code>
          %p.doc
            %i
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
        %td
          :coderay
            #!ruby
            band.tags << Tag.new(name: "electro")
            band.tags.push(Tag.new(name: "electro"))
        %td
          :coderay
            #!ruby
            collections[:tags].insert(
              { name: "electro", band_ids: ... }
            )
            collections[:bands].find(...).
              update("$push" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.concat</code>
          %p.doc
            %i
              Push multiple documents onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved in a single batch.
              <b>Note that while batch operations limit the number
              of database calls to a single one for the new documents, it
              is in fact at least 2x slower from the Ruby side. This is due
              to the fact that 2 iterations over all documents must occur
              to ensure that all the before callbacks run before the db hit,
              and that all after callbacks have to wait until after.</b>

        %td
          :coderay
            #!ruby
            band.tags.concat(
              Tag.new(name: "electro"),
              Tag.new(name: "new wave")
            )
        %td
          :coderay
            #!ruby
            collections[:tags].insert([
              { name: "electro", band_ids: ... },
              { name: "new wave", band_ids: ... }
            ])
            collections[:bands].find(...).
              update("$pushAll" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.build</code><br/>
          <code>Model\#{name}.new</code>
          %p.doc
            %i
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
        %td
          :coderay
            #!ruby
            band.tags.build(name: "electro")
            band.tags.new(name: "electro")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.create</code><br/>
          <code>Model\#{name}.create!</code>
          %p.doc
            %i
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
        %td
          :coderay
            #!ruby
            band.tags.create(name: "electro")
            band.tags.create!(name: "electro")
        %td
          :coderay
            #!ruby
            collections[:tags].insert(
              { name: "electro", band_ids: ... }
            )
            collections[:bands].find(...).
              update("$push" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.clear</code><br/>
          <code>Model\#{name}.delete_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, without
              running any callbacks.
        %td
          :coderay
            #!ruby
            band.tags.clear
            band.tags.delete_all
            band.tags.delete_all(name: "electro")
            band.tags.
              where(name: "electro").delete_all
        %td
          :coderay
            #!ruby
            collections[:tags].find(_id: { "$in" => ... }).remove_all
            collections[:bands].find(...).
              update("$pullAll" => { tag_ids: ... })

            collections[:tags].
              find(_id: { "$in" => ... }, name: "electro").remove_all
            collections[:bands].find(...).
              update("$pullAll" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.destroy_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, while
              running the destroy callbacks.
        %td
          :coderay
            #!ruby
            band.tags.destroy_all
            band.tags.destroy_all(name: "electro")
            band.tags.
              where(name: "electro").destroy_all
        %td
          :coderay
            #!ruby
            collections[:tags].find(_id: { "$in" => ... }).remove_all
            collections[:bands].find(...).
              update("$pullAll" => { tag_ids: ... })

            collections[:tags].
              find(_id: { "$in" => ... }, name: "electro").remove_all
            collections[:bands].find(...).
              update("$pullAll" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.delete</code>
          %p.doc
            %i
              Deletes the matching document from the relation.
        %td
          :coderay
            #!ruby
            band.tags.delete(tag)
        %td
          :coderay
            #!ruby
            collections[:tags].
              find(_id: { "$in" => ... }, name: "electro").remove
            collections[:bands].find(...).
              update("$pull" => { tag_ids: ... })
      %tr
        %td.doc
          <code>Model\#{name}.find</code>
          %p.doc
            %i
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
        %td
          :coderay
            #!ruby
            band.tags.find(id)

            band.tags.find(id_one, id_two)
        %td
          :coderay
            #!ruby
            collections[:tags].find({
              _id: { "$in" => ... }, { "$and" => [{ _id: id }] }
            })

            collections[:tags].find({
              _id: { "$in" => ... },
              { "$and" => [{ _id: { "$in" => [ id_one, id_two ]}}] }
            })
      %tr
        %td.doc
          <code>Model\#{name}.find_or_create_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              create a newly persisted one.
        %td
          :coderay
            #!ruby
            band.tags.
              find_or_create_by(name: "electro")
        %td
          :coderay
            #!ruby
            collections[:tags].find({
              _id: { "$in" => ... }, name: "electro"
            })
            collections[:tags].insert(
              { name: "electro", band_ids: ... }
            )
      %tr
        %td.doc
          <code>Model\#{name}.find_or_initialize_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              add a new one.
        %td
          :coderay
            #!ruby
            band.tags.
              find_or_initialize_by(name: "electro")
        %td
          :coderay
            #!ruby
            collections[:tags].find({
              _id: { "$in" => ... }, name: "electro"
            })
      %tr
        %td.doc
          <code>Model\#{name}.where</code>
          %p.doc
            %i
              Find matching documents in the relation. This can be any
              criteria method, not just where.
        %td
          :coderay
            #!ruby
            band.tags.where(name: "electro")
        %td
          :coderay
            #!ruby
            collections[:tags].find({
              _id: { "$in" => ... }, name: "electro"
            })
      %tr
        %td.doc
          <code>Model\#{name}.exists?</code>
          %p.doc
            %i
              Returns whether or not the relation has any documents.
        %td
          :coderay
            #!ruby
            band.tags.exists?
        %td
          :coderay
            #!ruby
            collections[:tags].
              find(_id: { "$in" => ... }).count
