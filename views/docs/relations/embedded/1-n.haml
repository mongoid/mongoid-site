%h1 embedded one to many

%p.image= link_to image_tag( '/images/relations/embedded-1-N.png'), '/images/relations/embedded-1-N.png', class: "diagram"

%p
  One to many relationships where the children are embedded in the parent
  document are defined using Mongoid's <tt>embeds_many</tt> and
  <tt>embedded_in</tt> macros.

%h3 setting up the models 

%p
  The parent document of the relation should use the <tt>embeds_many</tt>
  macro to indicate that it has <i>n</i> number of embedded children, where
  the document that is embedded uses <tt>embedded_in</tt>.

:coderay
  #!ruby

  class Person
    include Mongoid::Document
    embeds_many :addresses
  end

  class Address
    include Mongoid::Document
    field :city, type: String
    field :country, type: String
    embedded_in :person
  end

%p
  Definitions are required on both sides to the relation in order for it to
  work properly. <tt>:inverse_of</tt> is not required.

%h3 a model at the database level

%p
  Documents that are embedded in using the <tt>embeds_many</tt> macro are stored
  as an array of hashes inside the parent. 

%p
  For example, a Person which embeds many addresses will be represented in the database as follows:

:coderay
  #!javascript                                                                

  {
    "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
    "addresses" : [
      {
        "_id" : ObjectId("4d3ed089fb60ab534684b7e0"),
        "city" : "Berlin",
        "country" : "Deutschland"
      },
      {
        "_id" : ObjectId("4d61a5b4511ea72ca4000002"),
        "city" : "Namur",
        "country" : "Belgium"
      }
    ]
  }

%h3 accessors

%p
  The name of the associations defines the accessors methods. The following example shows basic access on both
  sides of the relation.

:coderay
  #!ruby

  # Return the child addresses.
  person.addresses

  # Set the child addresses.
  person.addresses = [ Address.new ]

  # Return the parent person.
  address.person

  # Set the parent person.
  address.person = Person.new

%h3 building and creating

%p
  From the parent side, documents in the embedded child can be appended to using
  traditional array syntax or the special association proxy methods. On the
  child side the only option is to replace the existing with a newly built or
  created document.

:coderay
  #!ruby

  # Append one or many child addresses, saving them if the person is persisted.
  person.addresses << Address.new
  person.addresses.push(Address.new)
  person.addresses.concat([ address ])

  # Appends and returns a new child address from the attributes.
  person.addresses.build(city: "Berlin")
  person.addresses.new(city: "Berlin")

  # Appends, saves, and returns a new child address from the attributes.
  person.addresses.create(city: "Berlin")

  # Appends, saves, and returns a new child address from the attributes,
  # raising an error if validation fails.
  person.addresses.create!(city: "Berlin")

  # Replace the parent with a new one from the attributes.
  address.build_person(title: "Prince")

  # Replace the parent with a newly saved one from the attributes.
  address.create_person(title: "Prince")                  

%h3 removal

%p
  Documents in the embedded many can be removed in several different manners,
  either through the relation, criteria, or accessors.

:coderay
  #!ruby

  # Delete all documents
  person.addresses.delete_all
  person.addresses.clear
  person.addresses = []

  # Delete all matching documents.
  person.addresses.delete_all(conditions: { city: "Berlin" })
  person.addresses.where(city: "Berlin").delete_all

  # Destroy all documents, running destroy callbacks.
  person.addresses.destroy_all

  # Destroy all matching documents, running callbacks.
  person.addresses.destroy_all(conditions: { city: "Berlin" })
  person.addresses.where(city: "Berlin").destroy_all

  # Delete the parent document (Note this also deletes all children.)
  address.person.delete

  # Destroy the parent document (Note this also deletes all children.)
  address.person.destroy

%h3 finding

%p
  Finding documents in the embedded children is handled through <tt>find</tt>
  or by using chained criteria on the relation.

:coderay
  #!ruby

  # Find the first child that matches an id 
  person.addresses.find(id)                   # Returns an address.

  # Find one child for every id. 
  person.addresses.find([ id_one, id_two ])   # Returns an array of addresses.

  # Find matching children.
  person.addresses.where(city: "Berlin")

  # Find or create a matching (saved) child.
  person.addresses.find_or_create_by(city: "Berlin")

  # Find or initialize a matching (new) child.
  person.addresses.find_or_initialize_by(city: "Berlin")

  # Is any of these addresses persisted?
  person.addresses.exists?

  # Paginate the child documents.
  person.addresses.paginate(page: 2, per_page: 20)

%h3 polymorphic behaviour

%p
  When a child (embedded document) can belong to more than one type of parent
  document, you must add the <tt>as</tt>
  option on the definition of the parent documents, and the <tt>polymorphic</tt>
  option on the child.

:coderay
  #!ruby

  class Office
    include Mongoid::Document
    embeds_many :addresses, as: :locatable
  end

  class Person
    include Mongoid::Document
    embeds_many :addresses, as: :locatable
  end

  class Address
    include Mongoid::Document
    embedded_in :locatable, polymorphic: true
  end

%h3 custom relation names

%p
  You can name your relations whatever you like, but if the class cannot be
  inferred by Mongoid from the name, and neither can the opposite side you'll
  want to provide the macro with some additional options to tell Mongoid
  how to hook them up.

:coderay
  #!ruby

  class Lush
    include Mongoid::Document
    embeds_many :whiskeys, class_name: "Drink", inverse_of: :alcoholic
  end

  class Drink
    include Mongoid::Document
    embedded_in :alcoholic, class_name: "Lush", inverse_of: :whiskeys
  end
